import { GitRepository } from "./git-utils.ts";
import { SessionLog, WorkspaceManager } from "./workspace.ts";
import { execInDevcontainer } from "./devcontainer.ts";

interface ClaudeStreamMessage {
  type: string;
  subtype?: string;
  session_id?: string;
  message?: {
    id: string;
    type: string;
    role: string;
    model: string;
    content: Array<{
      type: string;
      text?: string;
    }>;
    stop_reason: string;
    usage?: {
      input_tokens: number;
      output_tokens: number;
    };
  };
  result?: string;
  is_error?: boolean;
}

export interface ClaudeCommandExecutor {
  execute(
    args: string[],
    cwd: string,
  ): Promise<{ code: number; stdout: Uint8Array; stderr: Uint8Array }>;

  executeStreaming?(
    args: string[],
    cwd: string,
    onData: (data: Uint8Array) => void,
  ): Promise<{ code: number; stderr: Uint8Array }>;
}

class DefaultClaudeCommandExecutor implements ClaudeCommandExecutor {
  async execute(
    args: string[],
    cwd: string,
  ): Promise<{ code: number; stdout: Uint8Array; stderr: Uint8Array }> {
    const command = new Deno.Command("claude", {
      args,
      cwd,
      stdout: "piped",
      stderr: "piped",
    });

    const { code, stdout, stderr } = await command.output();
    return { code, stdout, stderr };
  }

  async executeStreaming(
    args: string[],
    cwd: string,
    onData: (data: Uint8Array) => void,
  ): Promise<{ code: number; stderr: Uint8Array }> {
    const command = new Deno.Command("claude", {
      args,
      cwd,
      stdout: "piped",
      stderr: "piped",
    });

    const process = command.spawn();

    // stdout„Çí„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„ÅßË™≠„ÅøÂèñ„Çã
    const reader = process.stdout.getReader();

    (async () => {
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          if (value) {
            onData(value);
          }
        }
      } catch (error) {
        console.error("stdoutË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº:", error);
      } finally {
        reader.releaseLock();
      }
    })();

    // „Éó„É≠„Çª„Çπ„ÅÆÁµÇ‰∫Ü„ÇíÂæÖ„Å§
    const { code, stderr } = await process.output();

    return { code, stderr };
  }
}

export class DevcontainerClaudeExecutor implements ClaudeCommandExecutor {
  private readonly repositoryPath: string;

  constructor(repositoryPath: string) {
    this.repositoryPath = repositoryPath;
  }

  async execute(
    args: string[],
    _cwd: string,
  ): Promise<{ code: number; stdout: Uint8Array; stderr: Uint8Array }> {
    // devcontainerÂÜÖ„Åßclaude„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å
    const command = ["claude", ...args];
    return await execInDevcontainer(this.repositoryPath, command);
  }
}

export interface IWorker {
  processMessage(
    message: string,
    onProgress?: (content: string) => Promise<void>,
  ): Promise<string>;
  getName(): string;
  getRepository(): GitRepository | null;
  setRepository(repository: GitRepository, localPath: string): Promise<void>;
  setThreadId(threadId: string): void;
}

export class Worker implements IWorker {
  private readonly name: string;
  private repository: GitRepository | null = null;
  private worktreePath: string | null = null;
  private sessionId: string | null = null;
  private threadId: string | null = null;
  private claudeExecutor: ClaudeCommandExecutor;
  private readonly workspaceManager: WorkspaceManager;
  private useDevcontainer: boolean = false;
  private devcontainerStarted: boolean = false;
  private skipPermissions: boolean = false;

  constructor(
    name: string,
    workspaceManager: WorkspaceManager,
    claudeExecutor?: ClaudeCommandExecutor,
  ) {
    this.name = name;
    this.workspaceManager = workspaceManager;
    this.claudeExecutor = claudeExecutor || new DefaultClaudeCommandExecutor();
  }

  async processMessage(
    message: string,
    onProgress?: (content: string) => Promise<void>,
  ): Promise<string> {
    if (!this.repository || !this.worktreePath) {
      return "„É™„Éù„Ç∏„Éà„É™„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ/start „Ç≥„Éû„É≥„Éâ„Åß„É™„Éù„Ç∏„Éà„É™„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
    }

    try {
      // „Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„ÅÆË®òÈå≤Ôºà„Ç≥„Éû„É≥„ÉâÔºâ
      if (this.threadId) {
        await this.logSessionActivity("command", message);
      }

      // Âá¶ÁêÜÈñãÂßã„ÅÆÈÄöÁü•
      if (onProgress) {
        await onProgress("ü§ñ Claude„ÅåËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...");
      }

      const result = await this.executeClaude(message, onProgress);
      const formattedResponse = this.formatResponse(result);

      // „Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„ÅÆË®òÈå≤Ôºà„É¨„Çπ„Éù„É≥„ÇπÔºâ
      if (this.threadId) {
        await this.logSessionActivity("response", formattedResponse);
      }

      return formattedResponse;
    } catch (error) {
      console.error(`Worker ${this.name} - ClaudeÂÆüË°å„Ç®„É©„Éº:`, error);
      const errorMessage = `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${(error as Error).message}`;

      // „Ç®„É©„Éº„ÇÇ„Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„Å´Ë®òÈå≤
      if (this.threadId) {
        await this.logSessionActivity("error", errorMessage, {
          originalError: (error as Error).message,
          stack: (error as Error).stack,
        });
      }

      return errorMessage;
    }
  }

  private async executeClaude(
    prompt: string,
    onProgress?: (content: string) => Promise<void>,
  ): Promise<string> {
    const args = [
      "-p",
      prompt,
      "--output-format",
      "stream-json",
      "--verbose",
    ];

    // „Çª„ÉÉ„Ç∑„Éß„É≥Á∂ôÁ∂ö„ÅÆÂ†¥Âêà
    if (this.sessionId) {
      args.push("--resume", this.sessionId);
    }

    // --dangerously-skip-permissions „Ç™„Éó„Ç∑„Éß„É≥
    if (this.skipPermissions) {
      args.push("--dangerously-skip-permissions");
    }

    // „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°å„ÅåÂèØËÉΩ„Å™Â†¥Âêà
    if (this.claudeExecutor.executeStreaming && onProgress) {
      return await this.executeClaudeStreaming(args, onProgress);
    }

    // ÈÄöÂ∏∏„ÅÆÂÆüË°å
    const { code, stdout, stderr } = await this.claudeExecutor.execute(
      args,
      this.worktreePath!,
    );

    if (code !== 0) {
      const errorMessage = new TextDecoder().decode(stderr);
      throw new Error(`ClaudeÂÆüË°åÂ§±Êïó (ÁµÇ‰∫Ü„Ç≥„Éº„Éâ: ${code}): ${errorMessage}`);
    }

    const output = new TextDecoder().decode(stdout);
    return this.parseStreamJsonOutput(output, onProgress);
  }

  private async executeClaudeStreaming(
    args: string[],
    onProgress: (content: string) => Promise<void>,
  ): Promise<string> {
    const decoder = new TextDecoder();
    let buffer = "";
    let result = "";
    let newSessionId: string | null = null;
    let progressContent = "";
    let lastProgressUpdate = 0;
    const PROGRESS_UPDATE_INTERVAL = 1000; // 1Áßí„Åî„Å®„Å´Êõ¥Êñ∞
    let allOutput = "";

    const processLine = (line: string) => {
      if (!line.trim()) return;

      try {
        const parsed: ClaudeStreamMessage = JSON.parse(line);

        // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
        if (parsed.session_id) {
          newSessionId = parsed.session_id;
        }

        // „Ç¢„Ç∑„Çπ„Çø„É≥„Éà„É°„ÉÉ„Çª„Éº„Ç∏„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫
        if (parsed.type === "assistant" && parsed.message?.content) {
          for (const content of parsed.message.content) {
            if (content.type === "text" && content.text) {
              result += content.text;
              progressContent += content.text;

              // ÈÄ≤Êçó„ÅÆÊõ¥Êñ∞Ôºà‰∏ÄÂÆöÈñìÈöî„ÅßÔºâ
              const now = Date.now();
              if (
                progressContent.length > 50 &&
                now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL
              ) {
                // ÊúÄÂæå„ÅÆÂÆåÂÖ®„Å™Êñá„Åæ„Åü„ÅØÊÆµËêΩ„ÇíÈÄÅ‰ø°
                const lastNewline = progressContent.lastIndexOf("\n");
                if (lastNewline > 0) {
                  const toSend = progressContent.substring(0, lastNewline);
                  if (toSend.trim()) {
                    onProgress(this.formatResponse(toSend)).catch(
                      console.error,
                    );
                    lastProgressUpdate = now;
                  }
                }
              }
            }
          }
        }

        // ÊúÄÁµÇÁµêÊûú„ÇíÂèñÂæó
        if (parsed.type === "result" && parsed.result) {
          result = parsed.result;
        }
      } catch (parseError) {
        console.warn(`JSONËß£Êûê„Ç®„É©„Éº: ${parseError}, Ë°å: ${line}`);
      }
    };

    const onData = (data: Uint8Array) => {
      const chunk = decoder.decode(data, { stream: true });
      allOutput += chunk;
      buffer += chunk;

      // ÊîπË°å„ÅßÂàÜÂâ≤„Åó„Å¶Âá¶ÁêÜ
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";

      for (const line of lines) {
        processLine(line);
      }
    };

    const { code, stderr } = await this.claudeExecutor.executeStreaming!(
      args,
      this.worktreePath!,
      onData,
    );

    // ÊúÄÂæå„ÅÆ„Éê„ÉÉ„Éï„Ç°„ÇíÂá¶ÁêÜ
    if (buffer) {
      processLine(buffer);
    }

    if (code !== 0) {
      const errorMessage = decoder.decode(stderr);
      throw new Error(`ClaudeÂÆüË°åÂ§±Êïó (ÁµÇ‰∫Ü„Ç≥„Éº„Éâ: ${code}): ${errorMessage}`);
    }

    // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
    if (newSessionId) {
      this.sessionId = newSessionId;
    }

    // Áîü„ÅÆjsonl„Çí‰øùÂ≠ò
    if (this.repository?.fullName && allOutput.trim()) {
      await this.saveRawJsonlOutput(allOutput);
    }

    return result.trim() || "Claude „Åã„Çâ„ÅÆÂøúÁ≠î„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ";
  }

  private parseStreamJsonOutput(
    output: string,
    onProgress?: (content: string) => Promise<void>,
  ): string {
    const lines = output.trim().split("\n");
    let result = "";
    let newSessionId: string | null = null;
    let progressContent = "";
    let lastProgressUpdate = 0;
    const PROGRESS_UPDATE_INTERVAL = 1000; // 1Áßí„Åî„Å®„Å´Êõ¥Êñ∞

    // Áîü„ÅÆjsonl„Çí‰øùÂ≠ò
    if (this.repository?.fullName && output.trim()) {
      this.saveRawJsonlOutput(output);
    }

    for (const line of lines) {
      if (!line.trim()) continue;

      try {
        const parsed: ClaudeStreamMessage = JSON.parse(line);

        // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
        if (parsed.session_id) {
          newSessionId = parsed.session_id;
        }

        // „Ç¢„Ç∑„Çπ„Çø„É≥„Éà„É°„ÉÉ„Çª„Éº„Ç∏„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫
        if (parsed.type === "assistant" && parsed.message?.content) {
          for (const content of parsed.message.content) {
            if (content.type === "text" && content.text) {
              result += content.text;
              progressContent += content.text;

              // ÈÄ≤Êçó„ÅÆÊõ¥Êñ∞Ôºà‰∏ÄÂÆöÈñìÈöî„ÅßÔºâ
              const now = Date.now();
              if (
                onProgress && progressContent.length > 50 &&
                now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL
              ) {
                // ÊúÄÂæå„ÅÆÂÆåÂÖ®„Å™Êñá„Åæ„Åü„ÅØÊÆµËêΩ„ÇíÈÄÅ‰ø°
                const lastNewline = progressContent.lastIndexOf("\n");
                if (lastNewline > 0) {
                  const toSend = progressContent.substring(0, lastNewline);
                  if (toSend.trim()) {
                    onProgress(this.formatResponse(toSend)).catch(
                      console.error,
                    );
                    lastProgressUpdate = now;
                  }
                }
              }
            }
          }
        }

        // ÊúÄÁµÇÁµêÊûú„ÇíÂèñÂæó
        if (parsed.type === "result" && parsed.result) {
          result = parsed.result;
        }
      } catch (parseError) {
        console.warn(`JSONËß£Êûê„Ç®„É©„Éº: ${parseError}, Ë°å: ${line}`);
        // JSONËß£Êûê„Åß„Åç„Å™„ÅÑË°å„ÅØ„Åù„ÅÆ„Åæ„ÅæÁµêÊûú„Å´Âê´„ÇÅ„Çã
        result += line + "\n";
      }
    }

    // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
    if (newSessionId) {
      this.sessionId = newSessionId;
    }

    return result.trim() || "Claude „Åã„Çâ„ÅÆÂøúÁ≠î„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ";
  }

  private async saveRawJsonlOutput(output: string): Promise<void> {
    if (!this.repository?.fullName || !this.sessionId) return;

    try {
      await this.workspaceManager.saveRawSessionJsonl(
        this.repository.fullName,
        this.sessionId,
        output,
      );
    } catch (error) {
      console.error("ÁîüJSONL„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
    }
  }

  private formatResponse(response: string): string {
    // Discord„ÅÆÊñáÂ≠óÊï∞Âà∂ÈôêÔºà2000ÊñáÂ≠óÔºâ„ÇíËÄÉÊÖÆ
    const maxLength = 1900; // ‰ΩôË£ï„ÇíÊåÅ„Å£„Å¶Â∞ë„ÅóÁü≠„Åè

    if (response.length <= maxLength) {
      // ANSI„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈô§Âéª
      return this.stripAnsiCodes(response);
    }

    // Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØÂàÜÂâ≤„Åó„Å¶ÊúÄÂàù„ÅÆÈÉ®ÂàÜ„Å†„ÅëËøî„Åô
    const truncated = response.substring(0, maxLength);
    const lastNewline = truncated.lastIndexOf("\n");

    // ÊîπË°å„ÅßÁ∂∫È∫ó„Å´Âàá„Çå„Çã‰ΩçÁΩÆ„Åå„ÅÇ„Çå„Å∞„ÄÅ„Åù„Åì„ÅßÂàá„Çã
    const finalResponse = lastNewline > maxLength * 0.8
      ? truncated.substring(0, lastNewline)
      : truncated;

    return this.stripAnsiCodes(finalResponse) +
      "\n\n*ÔºàÂøúÁ≠î„ÅåÈï∑„ÅÑ„Åü„ÇÅ„ÄÅ‰∏ÄÈÉ®„ÅÆ„ÅøË°®Á§∫„Åó„Å¶„ÅÑ„Åæ„ÅôÔºâ*";
  }

  private stripAnsiCodes(text: string): string {
    // ANSI„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈô§Âéª„Åô„ÇãÊ≠£Ë¶èË°®Áèæ
    // deno-lint-ignore no-control-regex
    return text.replace(/\x1b\[[0-9;]*[mGKHF]/g, "");
  }

  getName(): string {
    return this.name;
  }

  getRepository(): GitRepository | null {
    return this.repository;
  }

  async setRepository(
    repository: GitRepository,
    localPath: string,
  ): Promise<void> {
    this.repository = repository;

    if (this.threadId) {
      try {
        this.worktreePath = await this.workspaceManager.createWorktree(
          this.threadId,
          localPath,
        );

        const threadInfo = await this.workspaceManager.loadThreadInfo(
          this.threadId,
        );
        if (threadInfo) {
          threadInfo.repositoryFullName = repository.fullName;
          threadInfo.repositoryLocalPath = localPath;
          threadInfo.worktreePath = this.worktreePath;
          await this.workspaceManager.saveThreadInfo(threadInfo);
        }
      } catch (error) {
        console.error(`worktree„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`);
        this.worktreePath = localPath;
      }
    } else {
      this.worktreePath = localPath;
    }

    // devcontainer„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅØDevcontainerClaudeExecutor„Å´Âàá„ÇäÊõø„Åà
    if (this.useDevcontainer && this.worktreePath) {
      this.claudeExecutor = new DevcontainerClaudeExecutor(this.worktreePath);
    }

    this.sessionId = null;
  }

  setThreadId(threadId: string): void {
    this.threadId = threadId;
  }

  /**
   * devcontainer„ÅÆ‰ΩøÁî®„ÇíË®≠ÂÆö„Åô„Çã
   */
  setUseDevcontainer(useDevcontainer: boolean): void {
    this.useDevcontainer = useDevcontainer;
  }

  /**
   * devcontainer„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÇíÂèñÂæó
   */
  isUsingDevcontainer(): boolean {
    return this.useDevcontainer;
  }

  /**
   * devcontainer„ÅåËµ∑ÂãïÊ∏à„Åø„Åã„ÇíÂèñÂæó
   */
  isDevcontainerStarted(): boolean {
    return this.devcontainerStarted;
  }

  /**
   * --dangerously-skip-permissions „Ç™„Éó„Ç∑„Éß„É≥„ÅÆ‰ΩøÁî®„ÇíË®≠ÂÆö„Åô„Çã
   */
  setSkipPermissions(skipPermissions: boolean): void {
    this.skipPermissions = skipPermissions;
  }

  /**
   * --dangerously-skip-permissions „Ç™„Éó„Ç∑„Éß„É≥„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÇíÂèñÂæó
   */
  isSkipPermissions(): boolean {
    return this.skipPermissions;
  }

  /**
   * devcontainer„ÇíËµ∑Âãï„Åô„Çã
   */
  async startDevcontainer(
    onProgress?: (message: string) => Promise<void>,
  ): Promise<
    { success: boolean; containerId?: string; error?: string }
  > {
    if (!this.repository || !this.worktreePath) {
      return {
        success: false,
        error: "„É™„Éù„Ç∏„Éà„É™„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
      };
    }

    const { startDevcontainer } = await import("./devcontainer.ts");
    const result = await startDevcontainer(this.worktreePath, onProgress);

    if (result.success) {
      this.devcontainerStarted = true;
    }

    return result;
  }

  private async logSessionActivity(
    type: "command" | "response" | "error",
    content: string,
    metadata?: Record<string, unknown>,
  ): Promise<void> {
    if (!this.threadId) return;

    const sessionLog: SessionLog = {
      sessionId: this.sessionId || "no-session",
      threadId: this.threadId,
      timestamp: new Date().toISOString(),
      type,
      content,
      metadata: {
        ...metadata,
        repository: this.repository?.fullName,
        workerName: this.name,
      },
    };

    try {
      await this.workspaceManager.saveSessionLog(sessionLog);
    } catch (error) {
      console.error("„Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
    }
  }
}
