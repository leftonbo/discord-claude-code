import { GitRepository } from "./git-utils.ts";
import { SessionLog, WorkspaceManager } from "./workspace.ts";
import { execInDevcontainer } from "./devcontainer.ts";

interface ClaudeStreamMessage {
  type: string;
  subtype?: string;
  session_id?: string;
  message?: {
    id: string;
    type: string;
    role: string;
    model: string;
    content: Array<{
      type: string;
      text?: string;
    }>;
    stop_reason: string;
    usage?: {
      input_tokens: number;
      output_tokens: number;
    };
  };
  result?: string;
  is_error?: boolean;
}

export interface ClaudeCommandExecutor {
  execute(
    args: string[],
    cwd: string,
  ): Promise<{ code: number; stdout: Uint8Array; stderr: Uint8Array }>;

  executeStreaming?(
    args: string[],
    cwd: string,
    onData: (data: Uint8Array) => void,
  ): Promise<{ code: number; stderr: Uint8Array }>;
}

class DefaultClaudeCommandExecutor implements ClaudeCommandExecutor {
  async execute(
    args: string[],
    cwd: string,
  ): Promise<{ code: number; stdout: Uint8Array; stderr: Uint8Array }> {
    const command = new Deno.Command("claude", {
      args,
      cwd,
      stdout: "piped",
      stderr: "piped",
    });

    const { code, stdout, stderr } = await command.output();
    return { code, stdout, stderr };
  }

  async executeStreaming(
    args: string[],
    cwd: string,
    onData: (data: Uint8Array) => void,
  ): Promise<{ code: number; stderr: Uint8Array }> {
    const command = new Deno.Command("claude", {
      args,
      cwd,
      stdout: "piped",
      stderr: "piped",
    });

    const process = command.spawn();

    // stdout„Çí„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„ÅßË™≠„ÅøÂèñ„Çã
    const stdoutReader = process.stdout.getReader();
    const stderrReader = process.stderr.getReader();
    let stderrOutput = new Uint8Array();

    // stdout„ÅÆË™≠„ÅøÂèñ„ÇäPromise
    const stdoutPromise = (async () => {
      try {
        while (true) {
          const { done, value } = await stdoutReader.read();
          if (done) break;
          if (value) {
            onData(value);
          }
        }
      } catch (error) {
        console.error("stdoutË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº:", error);
      } finally {
        stdoutReader.releaseLock();
      }
    })();

    // stderr„ÅÆË™≠„ÅøÂèñ„ÇäPromise
    const stderrPromise = (async () => {
      try {
        const chunks: Uint8Array[] = [];
        while (true) {
          const { done, value } = await stderrReader.read();
          if (done) break;
          if (value) {
            chunks.push(value);
          }
        }
        // stderr„ÅÆÂÜÖÂÆπ„ÇíÁµêÂêà
        const totalLength = chunks.reduce(
          (sum, chunk) => sum + chunk.length,
          0,
        );
        stderrOutput = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          stderrOutput.set(chunk, offset);
          offset += chunk.length;
        }
      } catch (error) {
        console.error("stderrË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº:", error);
      } finally {
        stderrReader.releaseLock();
      }
    })();

    // „Éó„É≠„Çª„Çπ„ÅÆÁµÇ‰∫Ü„ÇíÂæÖ„Å§
    const [{ code }] = await Promise.all([
      process.status,
      stdoutPromise,
      stderrPromise,
    ]);

    return { code, stderr: stderrOutput };
  }
}

export class DevcontainerClaudeExecutor implements ClaudeCommandExecutor {
  private readonly repositoryPath: string;

  constructor(repositoryPath: string) {
    this.repositoryPath = repositoryPath;
  }

  async execute(
    args: string[],
    _cwd: string,
  ): Promise<{ code: number; stdout: Uint8Array; stderr: Uint8Array }> {
    // devcontainerÂÜÖ„Åßclaude„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å
    const command = ["claude", ...args];
    return await execInDevcontainer(this.repositoryPath, command);
  }

  async executeStreaming(
    args: string[],
    _cwd: string,
    onData: (data: Uint8Array) => void,
  ): Promise<{ code: number; stderr: Uint8Array }> {
    // devcontainerÂÜÖ„Åßclaude„Ç≥„Éû„É≥„Éâ„Çí„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°å
    const devcontainerCommand = new Deno.Command("devcontainer", {
      args: [
        "exec",
        "--workspace-folder",
        this.repositoryPath,
        "claude",
        ...args,
      ],
      stdout: "piped",
      stderr: "piped",
      cwd: this.repositoryPath,
      env: {
        ...Deno.env.toObject(),
        DOCKER_DEFAULT_PLATFORM: "linux/amd64",
      },
    });

    const process = devcontainerCommand.spawn();

    // stdout„Çí„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„ÅßË™≠„ÅøÂèñ„Çã
    const stdoutReader = process.stdout.getReader();
    const stderrReader = process.stderr.getReader();
    let stderrOutput = new Uint8Array();

    // stdout„ÅÆË™≠„ÅøÂèñ„ÇäPromise
    const stdoutPromise = (async () => {
      try {
        while (true) {
          const { done, value } = await stdoutReader.read();
          if (done) break;
          if (value) {
            onData(value);
          }
        }
      } catch (error) {
        console.error("devcontainer stdoutË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº:", error);
      } finally {
        stdoutReader.releaseLock();
      }
    })();

    // stderr„ÅÆË™≠„ÅøÂèñ„ÇäPromise
    const stderrPromise = (async () => {
      try {
        const chunks: Uint8Array[] = [];
        while (true) {
          const { done, value } = await stderrReader.read();
          if (done) break;
          if (value) {
            chunks.push(value);
          }
        }
        // stderr„ÅÆÂÜÖÂÆπ„ÇíÁµêÂêà
        const totalLength = chunks.reduce(
          (sum, chunk) => sum + chunk.length,
          0,
        );
        stderrOutput = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          stderrOutput.set(chunk, offset);
          offset += chunk.length;
        }
      } catch (error) {
        console.error("devcontainer stderrË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº:", error);
      } finally {
        stderrReader.releaseLock();
      }
    })();

    // „Éó„É≠„Çª„Çπ„ÅÆÁµÇ‰∫Ü„ÇíÂæÖ„Å§
    const [{ code }] = await Promise.all([
      process.status,
      stdoutPromise,
      stderrPromise,
    ]);

    return { code, stderr: stderrOutput };
  }
}

export interface IWorker {
  processMessage(
    message: string,
    onProgress?: (content: string) => Promise<void>,
  ): Promise<string>;
  getName(): string;
  getRepository(): GitRepository | null;
  setRepository(repository: GitRepository, localPath: string): Promise<void>;
  setThreadId(threadId: string): void;
}

export class Worker implements IWorker {
  private readonly name: string;
  private repository: GitRepository | null = null;
  private worktreePath: string | null = null;
  private sessionId: string | null = null;
  private threadId: string | null = null;
  private claudeExecutor: ClaudeCommandExecutor;
  private readonly workspaceManager: WorkspaceManager;
  private useDevcontainer: boolean = false;
  private devcontainerStarted: boolean = false;
  private skipPermissions: boolean = false;
  private verbose: boolean = false;

  constructor(
    name: string,
    workspaceManager: WorkspaceManager,
    claudeExecutor?: ClaudeCommandExecutor,
    verbose?: boolean,
  ) {
    this.name = name;
    this.workspaceManager = workspaceManager;
    this.claudeExecutor = claudeExecutor || new DefaultClaudeCommandExecutor();
    this.verbose = verbose || false;
  }

  async processMessage(
    message: string,
    onProgress?: (content: string) => Promise<void>,
  ): Promise<string> {
    this.logVerbose("„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÈñãÂßã", {
      messageLength: message.length,
      hasRepository: !!this.repository,
      hasWorktreePath: !!this.worktreePath,
      threadId: this.threadId,
      sessionId: this.sessionId,
    });

    if (!this.repository || !this.worktreePath) {
      this.logVerbose("„É™„Éù„Ç∏„Éà„É™„Åæ„Åü„ÅØworktree„Éë„Çπ„ÅåÊú™Ë®≠ÂÆö");
      return "„É™„Éù„Ç∏„Éà„É™„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ/start „Ç≥„Éû„É≥„Éâ„Åß„É™„Éù„Ç∏„Éà„É™„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
    }

    try {
      // „Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„ÅÆË®òÈå≤Ôºà„Ç≥„Éû„É≥„ÉâÔºâ
      if (this.threadId) {
        this.logVerbose("„Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„Å´„Ç≥„Éû„É≥„Éâ„ÇíË®òÈå≤");
        await this.logSessionActivity("command", message);
      }

      // Âá¶ÁêÜÈñãÂßã„ÅÆÈÄöÁü•
      if (onProgress) {
        this.logVerbose("ÈÄ≤ÊçóÈÄöÁü•ÈñãÂßã");
        await onProgress("ü§ñ Claude„ÅåËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...");
      }

      this.logVerbose("ClaudeÂÆüË°åÈñãÂßã");
      const result = await this.executeClaude(message, onProgress);
      this.logVerbose("ClaudeÂÆüË°åÂÆå‰∫Ü", { resultLength: result.length });

      const formattedResponse = this.formatResponse(result);
      this.logVerbose("„É¨„Çπ„Éù„É≥„ÇπÊï¥ÂΩ¢ÂÆå‰∫Ü", {
        formattedLength: formattedResponse.length,
      });

      // „Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„ÅÆË®òÈå≤Ôºà„É¨„Çπ„Éù„É≥„ÇπÔºâ
      if (this.threadId) {
        this.logVerbose("„Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„Å´„É¨„Çπ„Éù„É≥„Çπ„ÇíË®òÈå≤");
        await this.logSessionActivity("response", formattedResponse);
      }

      this.logVerbose("„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÂÆå‰∫Ü");
      return formattedResponse;
    } catch (error) {
      this.logVerbose("„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ„Ç®„É©„Éº", {
        errorMessage: (error as Error).message,
        errorStack: (error as Error).stack,
      });
      console.error(`Worker ${this.name} - ClaudeÂÆüË°å„Ç®„É©„Éº:`, error);
      const errorMessage = `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${(error as Error).message}`;

      // „Ç®„É©„Éº„ÇÇ„Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„Å´Ë®òÈå≤
      if (this.threadId) {
        await this.logSessionActivity("error", errorMessage, {
          originalError: (error as Error).message,
          stack: (error as Error).stack,
        });
      }

      return errorMessage;
    }
  }

  private async executeClaude(
    prompt: string,
    onProgress?: (content: string) => Promise<void>,
  ): Promise<string> {
    const args = [
      "-p",
      prompt,
      "--output-format",
      "stream-json",
    ];

    // verbose„É¢„Éº„Éâ„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„Åø--verbose„Ç™„Éó„Ç∑„Éß„É≥„ÇíËøΩÂä†
    if (this.verbose) {
      args.push("--verbose");
    }

    // „Çª„ÉÉ„Ç∑„Éß„É≥Á∂ôÁ∂ö„ÅÆÂ†¥Âêà
    if (this.sessionId) {
      args.push("--resume", this.sessionId);
      this.logVerbose("„Çª„ÉÉ„Ç∑„Éß„É≥Á∂ôÁ∂ö", { sessionId: this.sessionId });
    }

    // --dangerously-skip-permissions „Ç™„Éó„Ç∑„Éß„É≥
    if (this.skipPermissions) {
      args.push("--dangerously-skip-permissions");
      this.logVerbose("Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ„Çπ„Ç≠„ÉÉ„Éó„Çí‰ΩøÁî®");
    }

    this.logVerbose("Claude„Ç≥„Éû„É≥„ÉâÂÆüË°å", {
      args: args,
      cwd: this.worktreePath,
      useDevcontainer: this.useDevcontainer,
      hasStreaming: !!this.claudeExecutor.executeStreaming,
    });

    // „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°å„ÅåÂèØËÉΩ„Å™Â†¥Âêà
    if (this.claudeExecutor.executeStreaming && onProgress) {
      this.logVerbose("„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°åÈñãÂßã");
      return await this.executeClaudeStreaming(args, onProgress);
    }

    // ÈÄöÂ∏∏„ÅÆÂÆüË°å
    this.logVerbose("ÈÄöÂ∏∏ÂÆüË°åÈñãÂßã");
    const { code, stdout, stderr } = await this.claudeExecutor.execute(
      args,
      this.worktreePath!,
    );

    this.logVerbose("Claude„Ç≥„Éû„É≥„ÉâÂÆüË°åÂÆå‰∫Ü", {
      exitCode: code,
      stdoutLength: stdout.length,
      stderrLength: stderr.length,
    });

    if (code !== 0) {
      const errorMessage = new TextDecoder().decode(stderr);
      this.logVerbose("ClaudeÂÆüË°å„Ç®„É©„Éº", { exitCode: code, errorMessage });
      throw new Error(`ClaudeÂÆüË°åÂ§±Êïó (ÁµÇ‰∫Ü„Ç≥„Éº„Éâ: ${code}): ${errorMessage}`);
    }

    const output = new TextDecoder().decode(stdout);
    this.logVerbose("Âá∫ÂäõËß£ÊûêÈñãÂßã", { outputLength: output.length });
    return this.parseStreamJsonOutput(output, onProgress);
  }

  private async executeClaudeStreaming(
    args: string[],
    onProgress: (content: string) => Promise<void>,
  ): Promise<string> {
    this.logVerbose("„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°åË©≥Á¥∞ÈñãÂßã");
    const decoder = new TextDecoder();
    let buffer = "";
    let result = "";
    let newSessionId: string | null = null;
    let progressContent = "";
    let lastProgressUpdate = 0;
    const PROGRESS_UPDATE_INTERVAL = 1000; // 1Áßí„Åî„Å®„Å´Êõ¥Êñ∞
    let allOutput = "";
    let processedLines = 0;

    const processLine = (line: string) => {
      if (!line.trim()) return;
      processedLines++;

      try {
        const parsed: ClaudeStreamMessage = JSON.parse(line);
        this.logVerbose(`„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞Ë°åÂá¶ÁêÜ: ${parsed.type}`, {
          lineNumber: processedLines,
          hasSessionId: !!parsed.session_id,
          hasMessage: !!parsed.message,
        });

        // JSONLÂêÑË°å„ÅÆÈÄ≤Êçó„ÇíDiscord„Å´ÈÄÅ‰ø°
        if (onProgress) {
          const progressMessage = this.createProgressMessage(
            parsed,
            processedLines,
          );
          if (progressMessage) {
            onProgress(progressMessage).catch(console.error);
          }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
        if (parsed.session_id) {
          newSessionId = parsed.session_id;
          this.logVerbose("Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥IDÂèñÂæó", {
            sessionId: newSessionId,
          });
        }

        // „Ç¢„Ç∑„Çπ„Çø„É≥„Éà„É°„ÉÉ„Çª„Éº„Ç∏„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫
        if (parsed.type === "assistant" && parsed.message?.content) {
          for (const content of parsed.message.content) {
            if (content.type === "text" && content.text) {
              result += content.text;
              progressContent += content.text;

              // ÈÄ≤Êçó„ÅÆÊõ¥Êñ∞Ôºà‰∏ÄÂÆöÈñìÈöî„ÅßÔºâ
              const now = Date.now();
              if (
                progressContent.length > 50 &&
                now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL
              ) {
                // ÊúÄÂæå„ÅÆÂÆåÂÖ®„Å™Êñá„Åæ„Åü„ÅØÊÆµËêΩ„ÇíÈÄÅ‰ø°
                const lastNewline = progressContent.lastIndexOf("\n");
                if (lastNewline > 0) {
                  const toSend = progressContent.substring(0, lastNewline);
                  if (toSend.trim()) {
                    this.logVerbose("ÈÄ≤ÊçóÊõ¥Êñ∞ÈÄÅ‰ø°", {
                      contentLength: toSend.length,
                      timeSinceLastUpdate: now - lastProgressUpdate,
                    });
                    onProgress(this.formatResponse(toSend)).catch(
                      console.error,
                    );
                    lastProgressUpdate = now;
                  }
                }
              }
            }
          }
        }

        // ÊúÄÁµÇÁµêÊûú„ÇíÂèñÂæó
        if (parsed.type === "result" && parsed.result) {
          result = parsed.result;
          this.logVerbose("ÊúÄÁµÇÁµêÊûúÂèñÂæó", { resultLength: result.length });
        }
      } catch (parseError) {
        this.logVerbose(`JSONËß£Êûê„Ç®„É©„Éº: ${parseError}`, {
          line: line.substring(0, 100),
        });
        console.warn(`JSONËß£Êûê„Ç®„É©„Éº: ${parseError}, Ë°å: ${line}`);
      }
    };

    const onData = (data: Uint8Array) => {
      const chunk = decoder.decode(data, { stream: true });
      allOutput += chunk;
      buffer += chunk;

      // ÊîπË°å„ÅßÂàÜÂâ≤„Åó„Å¶Âá¶ÁêÜ
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";

      for (const line of lines) {
        processLine(line);
      }
    };

    const { code, stderr } = await this.claudeExecutor.executeStreaming!(
      args,
      this.worktreePath!,
      onData,
    );

    this.logVerbose("„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°åÂÆå‰∫Ü", {
      exitCode: code,
      stderrLength: stderr.length,
      totalOutputLength: allOutput.length,
      processedLines,
      hasNewSessionId: !!newSessionId,
    });

    // ÊúÄÂæå„ÅÆ„Éê„ÉÉ„Éï„Ç°„ÇíÂá¶ÁêÜ
    if (buffer) {
      this.logVerbose("ÊúÄÁµÇ„Éê„ÉÉ„Éï„Ç°Âá¶ÁêÜ", { bufferLength: buffer.length });
      processLine(buffer);
    }

    if (code !== 0) {
      const errorMessage = decoder.decode(stderr);
      this.logVerbose("„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂÆüË°å„Ç®„É©„Éº", {
        exitCode: code,
        errorMessage,
      });
      throw new Error(`ClaudeÂÆüË°åÂ§±Êïó (ÁµÇ‰∫Ü„Ç≥„Éº„Éâ: ${code}): ${errorMessage}`);
    }

    // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
    if (newSessionId) {
      this.sessionId = newSessionId;
      this.logVerbose("„Çª„ÉÉ„Ç∑„Éß„É≥IDÊõ¥Êñ∞", {
        oldSessionId: this.sessionId,
        newSessionId,
      });
    }

    // Áîü„ÅÆjsonl„Çí‰øùÂ≠ò
    if (this.repository?.fullName && allOutput.trim()) {
      this.logVerbose("ÁîüJSONL„Çí‰øùÂ≠ò", { outputLength: allOutput.length });
      await this.saveRawJsonlOutput(allOutput);
    }

    const finalResult = result.trim() ||
      "Claude „Åã„Çâ„ÅÆÂøúÁ≠î„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ";
    this.logVerbose("„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞Âá¶ÁêÜÂÆå‰∫Ü", {
      finalResultLength: finalResult.length,
    });
    return finalResult;
  }

  private parseStreamJsonOutput(
    output: string,
    onProgress?: (content: string) => Promise<void>,
  ): string {
    const lines = output.trim().split("\n");
    let result = "";
    let newSessionId: string | null = null;
    let progressContent = "";
    let lastProgressUpdate = 0;
    const PROGRESS_UPDATE_INTERVAL = 1000; // 1Áßí„Åî„Å®„Å´Êõ¥Êñ∞
    let processedLines = 0;

    // Áîü„ÅÆjsonl„Çí‰øùÂ≠ò
    if (this.repository?.fullName && output.trim()) {
      this.saveRawJsonlOutput(output);
    }

    for (const line of lines) {
      if (!line.trim()) continue;
      processedLines++;

      try {
        const parsed: ClaudeStreamMessage = JSON.parse(line);

        // JSONLÂêÑË°å„ÅÆÈÄ≤Êçó„ÇíDiscord„Å´ÈÄÅ‰ø°
        if (onProgress) {
          const progressMessage = this.createProgressMessage(
            parsed,
            processedLines,
          );
          if (progressMessage) {
            onProgress(progressMessage).catch(console.error);
          }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
        if (parsed.session_id) {
          newSessionId = parsed.session_id;
        }

        // „Ç¢„Ç∑„Çπ„Çø„É≥„Éà„É°„ÉÉ„Çª„Éº„Ç∏„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫
        if (parsed.type === "assistant" && parsed.message?.content) {
          for (const content of parsed.message.content) {
            if (content.type === "text" && content.text) {
              result += content.text;
              progressContent += content.text;

              // ÈÄ≤Êçó„ÅÆÊõ¥Êñ∞Ôºà‰∏ÄÂÆöÈñìÈöî„ÅßÔºâ
              const now = Date.now();
              if (
                onProgress && progressContent.length > 50 &&
                now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL
              ) {
                // ÊúÄÂæå„ÅÆÂÆåÂÖ®„Å™Êñá„Åæ„Åü„ÅØÊÆµËêΩ„ÇíÈÄÅ‰ø°
                const lastNewline = progressContent.lastIndexOf("\n");
                if (lastNewline > 0) {
                  const toSend = progressContent.substring(0, lastNewline);
                  if (toSend.trim()) {
                    onProgress(this.formatResponse(toSend)).catch(
                      console.error,
                    );
                    lastProgressUpdate = now;
                  }
                }
              }
            }
          }
        }

        // ÊúÄÁµÇÁµêÊûú„ÇíÂèñÂæó
        if (parsed.type === "result" && parsed.result) {
          result = parsed.result;
        }
      } catch (parseError) {
        console.warn(`JSONËß£Êûê„Ç®„É©„Éº: ${parseError}, Ë°å: ${line}`);
        // JSONËß£Êûê„Åß„Åç„Å™„ÅÑË°å„ÅØ„Åù„ÅÆ„Åæ„ÅæÁµêÊûú„Å´Âê´„ÇÅ„Çã
        result += line + "\n";
      }
    }

    // „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊõ¥Êñ∞
    if (newSessionId) {
      this.sessionId = newSessionId;
    }

    return result.trim() || "Claude „Åã„Çâ„ÅÆÂøúÁ≠î„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ";
  }

  private async saveRawJsonlOutput(output: string): Promise<void> {
    if (!this.repository?.fullName || !this.sessionId) return;

    try {
      await this.workspaceManager.saveRawSessionJsonl(
        this.repository.fullName,
        this.sessionId,
        output,
      );
    } catch (error) {
      console.error("ÁîüJSONL„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
    }
  }

  private formatResponse(response: string): string {
    // Discord„ÅÆÊñáÂ≠óÊï∞Âà∂ÈôêÔºà2000ÊñáÂ≠óÔºâ„ÇíËÄÉÊÖÆ
    const maxLength = 1900; // ‰ΩôË£ï„ÇíÊåÅ„Å£„Å¶Â∞ë„ÅóÁü≠„Åè

    if (response.length <= maxLength) {
      // ANSI„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈô§Âéª
      return this.stripAnsiCodes(response);
    }

    // Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØÂàÜÂâ≤„Åó„Å¶ÊúÄÂàù„ÅÆÈÉ®ÂàÜ„Å†„ÅëËøî„Åô
    const truncated = response.substring(0, maxLength);
    const lastNewline = truncated.lastIndexOf("\n");

    // ÊîπË°å„ÅßÁ∂∫È∫ó„Å´Âàá„Çå„Çã‰ΩçÁΩÆ„Åå„ÅÇ„Çå„Å∞„ÄÅ„Åù„Åì„ÅßÂàá„Çã
    const finalResponse = lastNewline > maxLength * 0.8
      ? truncated.substring(0, lastNewline)
      : truncated;

    return this.stripAnsiCodes(finalResponse) +
      "\n\n*ÔºàÂøúÁ≠î„ÅåÈï∑„ÅÑ„Åü„ÇÅ„ÄÅ‰∏ÄÈÉ®„ÅÆ„ÅøË°®Á§∫„Åó„Å¶„ÅÑ„Åæ„ÅôÔºâ*";
  }

  private stripAnsiCodes(text: string): string {
    // ANSI„Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈô§Âéª„Åô„ÇãÊ≠£Ë¶èË°®Áèæ
    // deno-lint-ignore no-control-regex
    return text.replace(/\x1b\[[0-9;]*[mGKHF]/g, "");
  }

  getName(): string {
    return this.name;
  }

  getRepository(): GitRepository | null {
    return this.repository;
  }

  async setRepository(
    repository: GitRepository,
    localPath: string,
  ): Promise<void> {
    this.logVerbose("„É™„Éù„Ç∏„Éà„É™Ë®≠ÂÆöÈñãÂßã", {
      repositoryFullName: repository.fullName,
      localPath,
      hasThreadId: !!this.threadId,
      useDevcontainer: this.useDevcontainer,
    });

    this.repository = repository;

    if (this.threadId) {
      try {
        this.logVerbose("worktree‰ΩúÊàêÈñãÂßã", { threadId: this.threadId });
        this.worktreePath = await this.workspaceManager.createWorktree(
          this.threadId,
          localPath,
        );
        this.logVerbose("worktree‰ΩúÊàêÂÆå‰∫Ü", {
          worktreePath: this.worktreePath,
        });

        const threadInfo = await this.workspaceManager.loadThreadInfo(
          this.threadId,
        );
        if (threadInfo) {
          threadInfo.repositoryFullName = repository.fullName;
          threadInfo.repositoryLocalPath = localPath;
          threadInfo.worktreePath = this.worktreePath;
          await this.workspaceManager.saveThreadInfo(threadInfo);
          this.logVerbose("„Çπ„É¨„ÉÉ„ÉâÊÉÖÂ†±Êõ¥Êñ∞ÂÆå‰∫Ü");
        }
      } catch (error) {
        this.logVerbose("worktree‰ΩúÊàêÂ§±Êïó„ÄÅlocalPath„Çí‰ΩøÁî®", {
          error: (error as Error).message,
          fallbackPath: localPath,
        });
        console.error(`worktree„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`);
        this.worktreePath = localPath;
      }
    } else {
      this.logVerbose("threadId„Å™„Åó„ÄÅlocalPath„ÇíÁõ¥Êé•‰ΩøÁî®");
      this.worktreePath = localPath;
    }

    // devcontainer„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅØDevcontainerClaudeExecutor„Å´Âàá„ÇäÊõø„Åà
    if (this.useDevcontainer && this.worktreePath) {
      this.logVerbose("DevcontainerClaudeExecutor„Å´Âàá„ÇäÊõø„Åà");
      this.claudeExecutor = new DevcontainerClaudeExecutor(this.worktreePath);
    }

    this.sessionId = null;
    this.logVerbose("„É™„Éù„Ç∏„Éà„É™Ë®≠ÂÆöÂÆå‰∫Ü", {
      finalWorktreePath: this.worktreePath,
      executorType: this.useDevcontainer
        ? "DevcontainerClaudeExecutor"
        : "DefaultClaudeCommandExecutor",
    });
  }

  setThreadId(threadId: string): void {
    this.threadId = threadId;
  }

  /**
   * devcontainer„ÅÆ‰ΩøÁî®„ÇíË®≠ÂÆö„Åô„Çã
   */
  setUseDevcontainer(useDevcontainer: boolean): void {
    this.useDevcontainer = useDevcontainer;
  }

  /**
   * devcontainer„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÇíÂèñÂæó
   */
  isUsingDevcontainer(): boolean {
    return this.useDevcontainer;
  }

  /**
   * devcontainer„ÅåËµ∑ÂãïÊ∏à„Åø„Åã„ÇíÂèñÂæó
   */
  isDevcontainerStarted(): boolean {
    return this.devcontainerStarted;
  }

  /**
   * --dangerously-skip-permissions „Ç™„Éó„Ç∑„Éß„É≥„ÅÆ‰ΩøÁî®„ÇíË®≠ÂÆö„Åô„Çã
   */
  setSkipPermissions(skipPermissions: boolean): void {
    this.skipPermissions = skipPermissions;
  }

  /**
   * --dangerously-skip-permissions „Ç™„Éó„Ç∑„Éß„É≥„Åå‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÇíÂèñÂæó
   */
  isSkipPermissions(): boolean {
    return this.skipPermissions;
  }

  /**
   * verbose„É¢„Éº„Éâ„ÇíË®≠ÂÆö„Åô„Çã
   */
  setVerbose(verbose: boolean): void {
    this.verbose = verbose;
  }

  /**
   * verbose„É¢„Éº„Éâ„ÅåÊúâÂäπ„Åã„ÇíÂèñÂæó
   */
  isVerbose(): boolean {
    return this.verbose;
  }

  /**
   * JSONLË°å„Åã„ÇâÈÄ≤Êçó„É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàê„Åô„Çã
   */
  private createProgressMessage(
    parsed: ClaudeStreamMessage,
    lineNumber: number,
  ): string | null {
    switch (parsed.type) {
      case "task_start":
        return `üîç [${lineNumber}] „Çø„Çπ„ÇØÈñãÂßã: ÂàÜÊûê‰∏≠...`;

      case "tool_use":
        return `üõ†Ô∏è [${lineNumber}] „ÉÑ„Éº„É´‰ΩøÁî®‰∏≠...`;

      case "thinking":
        return `üí≠ [${lineNumber}] ÊÄùËÄÉ‰∏≠...`;

      case "assistant":
        if (parsed.message?.content?.some((c) => c.type === "text")) {
          return `‚úçÔ∏è [${lineNumber}] ÂõûÁ≠îÁîüÊàê‰∏≠...`;
        }
        return null;

      case "result":
        return `‚úÖ [${lineNumber}] Âá¶ÁêÜÂÆå‰∫Ü`;

      case "error":
        return `‚ùå [${lineNumber}] „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü`;

      case "session_start":
        return `üéØ [${lineNumber}] „Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã`;

      case "session_end":
        return `üèÅ [${lineNumber}] „Çª„ÉÉ„Ç∑„Éß„É≥ÁµÇ‰∫Ü`;

      default:
        // „Åù„ÅÆ‰ªñ„ÅÆ„Çø„Ç§„Éó„ÅØÈôêÂÆöÁöÑ„Å´Ë°®Á§∫
        if (
          parsed.type && !["ping", "metadata", "debug"].includes(parsed.type)
        ) {
          return `‚ö° [${lineNumber}] ${parsed.type}`;
        }
        return null;
    }
  }

  /**
   * verbose„É≠„Ç∞„ÇíÂá∫Âäõ„Åô„Çã
   */
  private logVerbose(
    message: string,
    metadata?: Record<string, unknown>,
  ): void {
    if (this.verbose) {
      const timestamp = new Date().toISOString();
      const logMessage = `[${timestamp}] [Worker:${this.name}] ${message}`;
      console.log(logMessage);

      if (metadata && Object.keys(metadata).length > 0) {
        console.log(
          `[${timestamp}] [Worker:${this.name}] „É°„Çø„Éá„Éº„Çø:`,
          metadata,
        );
      }
    }
  }

  /**
   * devcontainer„ÇíËµ∑Âãï„Åô„Çã
   */
  async startDevcontainer(
    onProgress?: (message: string) => Promise<void>,
  ): Promise<
    { success: boolean; containerId?: string; error?: string }
  > {
    if (!this.repository || !this.worktreePath) {
      return {
        success: false,
        error: "„É™„Éù„Ç∏„Éà„É™„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
      };
    }

    const { startDevcontainer } = await import("./devcontainer.ts");
    const result = await startDevcontainer(this.worktreePath, onProgress);

    if (result.success) {
      this.devcontainerStarted = true;
    }

    return result;
  }

  private async logSessionActivity(
    type: "command" | "response" | "error",
    content: string,
    metadata?: Record<string, unknown>,
  ): Promise<void> {
    if (!this.threadId) return;

    const sessionLog: SessionLog = {
      sessionId: this.sessionId || "no-session",
      threadId: this.threadId,
      timestamp: new Date().toISOString(),
      type,
      content,
      metadata: {
        ...metadata,
        repository: this.repository?.fullName,
        workerName: this.name,
      },
    };

    try {
      await this.workspaceManager.saveSessionLog(sessionLog);
    } catch (error) {
      console.error("„Çª„ÉÉ„Ç∑„Éß„É≥„É≠„Ç∞„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
    }
  }
}
